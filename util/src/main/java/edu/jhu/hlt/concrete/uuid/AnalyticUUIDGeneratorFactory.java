/*
 * Copyright 2012-2016 Johns Hopkins University HLTCOE. All rights reserved.
 * See LICENSE in the project root directory.
 */
package edu.jhu.hlt.concrete.uuid;

import java.util.Random;

import edu.jhu.hlt.concrete.Communication;
import edu.jhu.hlt.concrete.UUID;

/**
 * A class used to generate compressible UUIDs. One factory
 * should be created for each {@link Communication} object.
 * Each analytic then creates an {@link AnalyticUUIDGenerator}
 * by calling {@link #create()}. Commonly, each program
 * will represent a single analytic. Usage then can occur thusly:
 * <br><br>
 * <pre>
 * Communication c = ... // from an existing Communication
 * AnalyticUUIDGeneratorFactory f = new AnalyticUUIDGeneratorFactory(c); // per-comm
 * AnalyticUUIDGenerator gen = f.create(); // per-analytic
 * UUID newUUID = gen.next(); // concrete UUID
 * TokenTagging tt = new TokenTagging();
 * tt.setUuid(newUUID);
 * ...
 * </pre>
 *
 * or, for a new Communication:
 * <pre>
 * AnalyticUUIDGeneratorFactory f = new AnalyticUUIDGeneratorFactory(); // no-arg ctor
 * AnalyticUUIDGenerator gen = f.create();
 * Communication c = new Communication();
 * c.setUuid(gen.next());
 * </pre>
 */
public class AnalyticUUIDGeneratorFactory {

  // The local UUID. Represents a non-changing
  // part of the UUID. Compression gains come from re-using
  // the first parts of this.
  private final java.util.UUID localID;

  // An instance of random, used to select
  // hex characters.
  private static final Random r = new Random();

  // Valid hexadecimal characters.
  public static final String HEX_ALPHA = "abcdef1234567890";
  // The length of the hex alphabet above.
  public static final int HEX_ALPHA_LEN = HEX_ALPHA.length();

  /**
   * Constructor for a new {@link Communication} object, e.g.
   * from an ingester.
   */
  public AnalyticUUIDGeneratorFactory() {
    this.localID = generateUUIDUnif();
  }

  /**
   * Constructor for an existing {@link Communication}, e.g.
   * obtained from a previously annotated communication from
   * disk.
   * @param comm a previously created {@link Communication} object
   */
  public AnalyticUUIDGeneratorFactory(Communication comm) {
    this.localID = java.util.UUID.fromString(comm.getUuid().getUuidString());
  }

  /**
   * @return an {@link AnalyticUUIDGenerator} object, from which
   * new {@link UUID}s can be generated via {@link AnalyticUUIDGenerator#next()}
   */
  public AnalyticUUIDGenerator create() {
    return new AnalyticUUIDGenerator(this.localID);
  }

  /**
   * @return the local {@link java.util.UUID} as a string.
   */
  public final String getUuidString() {
    return this.localID.toString();
  }

  /**
   *
   * @return the local {@link java.util.UUID}
   */
  public final java.util.UUID getUuid() {
    return this.localID;
  }

  /**
   * A utility inner class, mirroring the python API, used to
   * expose per-analytic {@link UUID} generation.
   */
  public static class AnalyticUUIDGenerator {
    private final String xPart;
    private final String yPart;

    private long zPart;
    private int zLen;
    private int zBound;


    /**
     * Single-arg constructor - take in a valid
     * {@link java.util.UUID}.
     * @param uuid a {@link java.util.UUID}
     */
    private AnalyticUUIDGenerator(java.util.UUID uuid) {
      UUIDTuple tuple = new UUIDTuple(uuid);
      this.xPart = tuple.p1;
      this.yPart = generateHexUnif(tuple.p2.length());

      String zPartStr = generateHexUnif(tuple.p3.length());
      this.zPart = Long.parseUnsignedLong(zPartStr, 16);
      this.zLen = zPartStr.length();
      this.zBound = (int)Math.pow(2, (4 * this.zLen));
    }

    /**
     * Given a long value, return the hexadecimal variant padded
     * by some number of zeroes.
     *
     * @param k the long to convert to hexadecimal
     * @param pad the number of zeroes to left-pad the number
     * @return a String, with the hexadecimal value of <code>k</code>,
     * padded by <code>pad</code> zeroes on the left
     */
    public static String zeroPaddedHex(long k, int pad) {
      String hexStr = Long.toHexString(k);
      int nZeroes = pad - hexStr.length();
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < nZeroes; i++)
        sb.append("0");
      sb.append(hexStr);
      return sb.toString();
    }

    /**
     * @return the next {@link UUID} object generated by this generator. Use this
     * method to generate UUIDs for your analytic.
     */
    public UUID next() {
      this.zPart = (this.zPart + 1) % this.zBound;
      String lastPart = zeroPaddedHex(zPart, zLen);
      return new UUID(joinUUID(this.xPart, this.yPart, lastPart).toString());
    }
  }

  /**
   *
   * @return a {@link java.util.UUID} from a function deemed
   * satisfactory for high-compression
   */
  private static java.util.UUID generateUUIDUnif() {
    return joinUUID(generateHexUnif(12),
            generateHexUnif(8),
            generateHexUnif(12));
  }

  /**
   * Given a three-part quasi-UUID, return a proper
   * {@link java.util.UUID} object.
   *
   * @param p1 length 12 string of hexadecimal characters
   * @param p2 length 8 string of hexadecimal characters
   * @param p3 length 12 string of hexadecimal characters
   * @return a {@link java.util.UUID}.
   */
  private static java.util.UUID joinUUID(String p1, String p2, String p3) {
    StringBuilder sb = new StringBuilder();
    sb.append(p1.substring(0, 8));
    sb.append("-");
    sb.append(p1.substring(8));
    sb.append("-");
    sb.append(p2.substring(0, 4));
    sb.append("-");
    sb.append(p2.substring(4));
    sb.append("-");
    sb.append(p3);
    return java.util.UUID.fromString(sb.toString());
  }

  /**
   *
   * @param n an integer representing the number of characters of hexadecimal to generate
   * @return a String, of length n, filled with random hexadecimal characters
   */
  public static String generateHexUnif(int n) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < n; i++) {
      Character c = HEX_ALPHA.charAt(r.nextInt(HEX_ALPHA_LEN));
      sb.append(c);
    }

    return sb.toString();
  }

  /**
   * Utility wrapper class for dealing with quasi-UUIDs.
   */
  private static class UUIDTuple {
    private final String p1;
    private final String p2;
    private final String p3;

    public UUIDTuple(final java.util.UUID uuid) {
      String[] spl = uuid.toString().split("-");
      this.p1 = spl[0] + spl[1];
      this.p2 = spl[2] + spl[3];
      this.p3 = spl[4];
    }
  }
}


