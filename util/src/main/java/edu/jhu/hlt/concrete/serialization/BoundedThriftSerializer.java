/*
 * Copyright 2012-2015 Johns Hopkins University HLTCOE. All rights reserved.
 * See LICENSE in the project root directory.
 */

package edu.jhu.hlt.concrete.serialization;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.Files;
import java.nio.file.Path;

import org.apache.thrift.TBase;
import org.apache.thrift.TFieldIdEnum;
import org.apache.thrift.protocol.TCompactProtocol;
import org.apache.thrift.protocol.TProtocolFactory;

import edu.jhu.hlt.acute.AutoCloseableIterator;
import edu.jhu.hlt.concrete.Communication;
import edu.jhu.hlt.concrete.serialization.iterators.TarArchiveBoundedThriftIterator;
import edu.jhu.hlt.concrete.serialization.iterators.TarGzArchiveBoundedThriftIterator;
import edu.jhu.hlt.concrete.util.ConcreteException;

/**
 * This class contains a type-bounded parameter and uses reflection to de/serialize Thrift objects in
 * a semi-generic manner.
 * <br/>
 * <br/>
 * Any 'thrift-like' Java class generated by the Thrift compiler can be used.
 * <br/>
 * <br/>
 * For de/serializing {@link Communication} objects, consumers should consult the implementations of
 * {@link CompactCommunicationSerializer} & related classes. These do not use reflection.
 *
 * @see CommunicationSerializer
 */
public class BoundedThriftSerializer<T extends TBase<T, ? extends TFieldIdEnum>> implements ThriftSerializer<T> {

  private final ThreadSafeThriftSerializer<T> ser;
  private final Class<T> clazz;
  private final Constructor<T> ctor;

  public BoundedThriftSerializer(Class<T> clazz) throws ConcreteException {
    this(clazz, new TCompactProtocol.Factory());
  }

  public BoundedThriftSerializer(Class<T> clazz, TProtocolFactory factory) throws ConcreteException {
    this.ser = new ThreadSafeThriftSerializer<>(factory);
    this.clazz = clazz;
    try {
      this.ctor = clazz.getConstructor();
    } catch (NoSuchMethodException e) {
      final String error = "Could not find no-arg ctor for class: " + clazz.getName()
          + "; ensure it is truly a Thrift-like (extends TBase...) object.";
      throw new ConcreteException(error, e);
    }
  }

  @Override
  public T fromBytes(T base, byte[] bytes) throws ConcreteException {
    return this.fromBytes(bytes);
  }

  public T fromBytes(byte[] bytes) throws ConcreteException {
    try {
      T inst = ctor.newInstance();
      return this.ser.fromBytes(inst, bytes);
    } catch (InvocationTargetException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {
      throw new ConcreteException(e);
    }
  }

  @Override
  public byte[] toBytes(T base) throws ConcreteException {
    return this.ser.toBytes(base);
  }

  @Override
  public T fromPath(T base, Path path) throws ConcreteException {
    return this.ser.fromPath(base, path);
  }

  @Override
  public T fromPathString(T base, String pathString) throws ConcreteException {
    return this.ser.fromPathString(base, pathString);
  }

  @Override
  public T fromInputStream(T base, InputStream is) throws ConcreteException {
    return this.ser.fromInputStream(base, is);
  }

  public AutoCloseableIterator<T> fromTar(Path path) throws ConcreteException, IOException {
    // in will be closed during AutoCloseable close() call.
    InputStream in = Files.newInputStream(path);
    return new TarArchiveBoundedThriftIterator<>(this.clazz, in);
  }

  public AutoCloseableIterator<T> fromTarGz(Path path) throws ConcreteException, IOException {
    // in will be closed during AutoCloseable close() call.
    InputStream in = Files.newInputStream(path);
    return new TarGzArchiveBoundedThriftIterator<>(this.clazz, in);
  }
}
